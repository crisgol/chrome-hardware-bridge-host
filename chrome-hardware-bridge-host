#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A simple native messaging host. Shows a Tkinter dialog with incoming messages
# that also allows to send message back to the webapp.

import struct
import sys
import threading
import Queue
import json
import urllib
import tempfile
import uuid
import win32api
import win32com.client

import pdfkit

try:
  import Tkinter
  import tkMessageBox
except ImportError:
  Tkinter = None
  
Debug = False

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
  import os, msvcrt
  msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
  msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

# Helper function that sends a message to the webapp.
def send_message(message):
   # Write message size.
  sys.stdout.write(struct.pack('I', len(message)))
  # Write the message itself.
  sys.stdout.write(message)
  sys.stdout.flush()

# Thread that reads messages from the webapp.
def read_thread_func(queue):
  message_number = 0
  while 1:
    # Read the message length (first 4 bytes).
    text_length_bytes = sys.stdin.read(4)

    if len(text_length_bytes) == 0:
      if queue:
        queue.put(None)
      sys.exit(0)

    try:
        # Unpack message length as 4 byte integer.
        text_length = struct.unpack('i', text_length_bytes)[0]

        # Read the text (JSON object) of the message.
        text = sys.stdin.read(text_length).decode('utf-8')
    except:
        text = ''
        print('Decode error: %s' % text)

    if queue:
        queue.put(text)
    else:
        # Procsss Input
        handler = MessageHandler(None)
        handler.handle(text)

class MessageHandler():
    def __init__(self, logger):
        self.logger = logger
        
    def log(self, message):
        if self.logger:
            self.logger.log(message)
            
    def response(self, message):
        self.log(">> %s" % message)
        send_message(message)

    def handle(self, message):
    
        self.log("<< %s" % message)    
        data = json.loads(message)        
    
        try:    
            if not 'action' in data:
                raise ValueError('action required')
        
            if data['action'] == 'print':
                pdf_path = tempfile.gettempdir() + "/" + str(uuid.uuid4()) + ".pdf"
                
                if 'printer' in data and data['printer'] != False:   
                    printer = data['printer']
                else:
                    printer = ''
            
                if 'url' in data:
                    self.log("Print from URL: %s" % data['url'])   
                    urllib.urlretrieve(data['url'], pdf_path)
                    self.log("PDF Retrieved")
                elif 'html' in data:
                    self.log("Print from HTML: %s" % data['html'])
                    pdfkit.from_string(data['html'], pdf_path)
                    self.log("PDF Generated")
                else:
                    raise ValueError('url or html required')
                
                win32api.ShellExecute(0, "printto", pdf_path, printer, ".", 0)
                
                # OK Response
                self.response(json.dumps({'status': 0}))
            elif data['action'] == 'list_printer':
                strComputer = "."
                objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator")
                objSWbemServices = objWMIService.ConnectServer(strComputer,"root\cimv2")
                colItems = objSWbemServices.ExecQuery("Select * from Win32_PrinterConfiguration")

                printers = []

                for objItem in colItems:
                    printers.append(objItem.Name)
                    
                self.response(json.dumps({'status': 0, 'action': 'list', 'type': 'printer', 'items': printers}))
            else:
                raise ValueError('Unknown action')  
            

        except Exception as e:
            # Error Response
            self.response(json.dumps({'status': 1, 'message': str(e)}))

if Tkinter:
  class NativeMessagingWindow(Tkinter.Frame):
    def __init__(self, queue):
      self.queue = queue

      Tkinter.Frame.__init__(self)
      self.pack()

      self.text = Tkinter.Text(self)
      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
      self.text.config(state=Tkinter.DISABLED, height=20, width=50)

      self.messageContent = Tkinter.StringVar()
      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)

      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
      self.sendButton.grid(row=1, column=1, padx=10, pady=10)

      self.after(100, self.processMessages)

    def processMessages(self):
      while not self.queue.empty():
        
        message = self.queue.get_nowait()
        if message == None:
            self.quit()
            return
        
        # Procsss Input
        handler = MessageHandler(self)
        handler.handle(message)
        
      self.after(100, self.processMessages)

    def onSend(self):
      text = '{"status": "' + self.messageContent.get() + '"}'
      self.log('>> %s' % text)
      try:
        send_message(text)
      except IOError:
        tkMessageBox.showinfo('Native Messaging Example',
                              'Failed to send message.')
        sys.exit(1)

    def log(self, message):
      self.text.config(state=Tkinter.NORMAL)
      self.text.insert(Tkinter.END, message + "\n")
      self.text.config(state=Tkinter.DISABLED)


def Main():
  if not Tkinter or Debug == False:
    #send_message('"Tkinter python module wasn\'t found. Running in headless ' +
    #             'mode. Please consider installing Tkinter."')
    read_thread_func(None)
    sys.exit(0)

  queue = Queue.Queue()

  main_window = NativeMessagingWindow(queue)
  main_window.master.title('Chrome Hardware Bridge')

  thread = threading.Thread(target=read_thread_func, args=(queue,))
  thread.daemon = True
  thread.start()

  main_window.mainloop()

  sys.exit(0)


if __name__ == '__main__':
  Main()
